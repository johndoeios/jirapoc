<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Your Connect App</title>
  <script src="https://connect-cdn.atl-paas.net/all.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="filterlogs.js"></script>
  <script src="updateTimeLogs.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <!-- Header -->
  <header>
    JIRA Sprint Assistant
  </header>


  <!-- Main Container -->
  <div class="container">

    <div class="dropdown-container">
      <div class="dropdown">
        <label for="team-selector">Select Project:</label>
        <select id="team-selector">
          <option value="team-a">Mobile</option>
          <option value="team-b">Bill Wallet</option>
          <option value="team-c">Web</option>
        </select>
      </div>
      <div class="dropdown">
        <label for="sprint-selector">Select Sprint:</label>
        <select id="sprint-selector">
          <option value="sprint-1">MOBL-04FEB</option>
          <option value="sprint-2">MOBL-18FEB</option>
        </select>
      </div>
    </div>

    <!-- Sprint Summary Chat -->
    <div class="chat-container">
      <div class="chat-header">
        Sprint Summary Generator
      </div>
      <div class="chat-content">
        <div class="message bot-message">
          Choose a template:
          <div class="chat-options">
            <a href="#" class="option-button" style="background: #005FA0;">What happened yesterday?</a>
            <a href="#" class="option-button">Day wise summary of a sprint</a>
            <a href="#" class="option-button">Day wise summary of an Assignee</a>
            <a href="#" class="option-button">Epic wise summary</a>
            <a href="#" class="option-button">Summarize by Categories (Release, Development, Bugfixes)</a>
          </div>
        </div>
      </div>
    </div>

    <!-- Team - Time Log Section -->
    <div class="section">
      <h2>Team Time Log</h2>
      <p>Day wise time logged by whole team in this sprint. Find your team's most productive and non-productive days.</p>
      <p><strong>Total Time Logged:</strong> <span id="total-time-logged">0</span> hours</p> 
      <br />
      <div class="team-timelog-container">
        <canvas id="timeLogBarChart"></canvas>
      </div>
    </div>

    <!-- Team - Time Log Section -->
    <div class="section">
      <h2>Team Score Cards</h2>
      <p><strong>Story Points Completion:</strong> <span id="story-points-completion">0%</span></p>
      <div id="team-members-container" class="team-member-grid"></div>
    </div>


    <!-- Charts -->
    <div class="pie-charts-container">
      <div class="chart-wrapper">
        <h3>Epic Storypoints Allocation</h3>
        <p id="chart-description">Check which epic consumed most story points</p>
        <canvas id="epic-allocation-chart"></canvas>
      </div>

      <div class="chart-wrapper">
        <h3>Epic Assignee Involved</h3>
        <p id="chart-description">Check which epic consumed most assignees</p>
        <canvas id="epic-assignee-allocation-chart"></canvas>
      </div>

      <div class="chart-wrapper">
        <h3>Epic Assignee Allocation</h3>
        <p id="chart-description">Check epic wise % allocaton of each assignee</p>
        <canvas id="epic-allocation-percentage-chart"></canvas>
      </div>
      
      <div class="chart-wrapper">
        <h3>Issue breakdown</h3>
        <p id="chart-description">Check breakdown of different issues status</p>
        <canvas id="issue-breakdown-chart"></canvas>
      </div>
      
    </div>
  </div>
Â 
<script type="module">

 import { SPRINT_NAME, PROJECT_NAME } from "./constants.js";
    // Store in local variables
    window.targetSprintName = SPRINT_NAME;
    // Variables for JSON file paths
    const responseJson = "responses/response.json";
    const epicJson = "responses/epic_response.json";
    const targetSprintName = window.targetSprintName || "";

    console.log("GotSprint from shell script", targetSprintName);

 function fetchDataAndInitialize() {
  fetch(responseJson)
    .then(response => response.json())
    .then(data => {
      return fetch(epicJson)
        .then(epicResponse => epicResponse.json())
        .then(epicData => {
          const issues = data.issues || [];
          const epicIssues = epicData.issues || [];
          const teamData = {};
          const epicStoryPointAllocation = {}; /*{"epic name": Total story points in this epic}*/
          const epicAssigneeInvolved = {}; /*{"epic name": Set of Unique Assignees}*/
          const assigneePercentageAllocation = {}; /*Assignee and its percentage in each epic*/
          const dailyTimeLogs = {};
          const statusBreakdown = {};
        
          issues.forEach(issue => {
            const assignee = issue.fields.assignee?.displayName || "Unassigned";
            const worklogs = issue.fields.worklog?.worklogs || [];
            const statusId = issue.fields.status?.id || "";
            const sprintField = issue.fields.customfield_10104 || [];
            const storyPoint = issue.fields.customfield_10102 || 0;
            const epicKey = issue.fields.customfield_10106 || null; // We check this for "Unassigned EPIC"
            const statusName = issue.fields.status?.name || "Unknown Status";
            
            statusBreakdown[statusName] = (statusBreakdown[statusName] || 0) + 1;

            if (!teamData[assignee]) {
              teamData[assignee] = {
                name: assignee,
                storyPoints: 0,
                completedStoryPoints: 0,
                timeSpent: 0,
                blockedTickets: 0,
                carryForwardTickets: 0,
                prs: 0,
                yetToStart: 0,
                completed: 0,
                epics: []
              };
            }
            
           const filteredWorklogs = getFilteredWorklogs(sprintField, worklogs, targetSprintName);
           console.log("Filtered Worklogs for Target Sprint:", filteredWorklogs);
           
           // BieGraph
           updateDailyTimeLogsAndTeamData(filteredWorklogs, dailyTimeLogs);

           updateTeamDataTime(filteredWorklogs, teamData);

           // PR 
           const pullrequests = getStateCountFromCustomField(issue.fields.customfield_11201);
          
            if (statusId === "6") {
              teamData[assignee].completed += 1;
              teamData[assignee].completedStoryPoints += storyPoint;
            }
            if (statusId === "1") {
              teamData[assignee].yetToStart += 1;
            }
            if (statusId === "10002") {
              teamData[assignee].blockedTickets += 1;
            }
            if (sprintField.length > 1) {
              teamData[assignee].carryForwardTickets += 1;
            }
            teamData[assignee].prs += pullrequests;
            teamData[assignee].storyPoints += storyPoint;

            // Check if customfield_10106 is null, and if so, assign "Unassigned EPIC"
            let epicName = "Unassigned EPIC";
            if (epicKey) {
              const matchingEpic = epicIssues.find(epic => epic.key === epicKey);
              
              if (matchingEpic) {
                epicName = matchingEpic.fields.customfield_10105 || "Unassigned EPIC"; // Fetch epic name if exists
              } else {
                console.log(`No matching epic found for epicKey: ${epicKey}`);
              }
            }

            // Add epic to assignee's epics list if not already included
            if (epicName && !teamData[assignee].epics.includes(epicName)) {
              teamData[assignee].epics.push(epicName);
            }

            // Pie charts
            updateEpicStoryPointAllocation(epicStoryPointAllocation, epicName, storyPoint);
            updateEpicAssigneeInvolved(epicAssigneeInvolved, epicName, assignee);
            updateAssigneePercentageAllocation(assigneePercentageAllocation, assignee, epicName, storyPoint);
          });

          console.log(assigneePercentageAllocation);
          console.log(epicStoryPointAllocation);

          const teamMembers = Object.values(teamData);
          const totalTimeLogged = teamMembers.reduce((sum, member) => sum + member.timeSpent, 0);
          // Calculate total planned and completed story points
          const totalStoryPointsPlanned = teamMembers.reduce((sum, member) => sum + member.storyPoints, 0);
          const totalStoryPointsAchieved = teamMembers.reduce((sum, member) => sum + member.completedStoryPoints, 0);

          // Calculate story points completion percentage
          const storyPointsCompletion = totalStoryPointsPlanned > 0 
              ? (totalStoryPointsAchieved / totalStoryPointsPlanned) * 100 
              : 0;
          document.getElementById("story-points-completion").textContent = `${totalStoryPointsAchieved}/${totalStoryPointsPlanned} (${storyPointsCompletion.toFixed(2)}%)`;
          document.getElementById("total-time-logged").textContent = totalTimeLogged.toFixed(2);
          generateTeamMemberCards(teamMembers);
          renderEpicCharts(epicStoryPointAllocation, epicAssigneeInvolved, assigneePercentageAllocation);
          renderStatusChart(statusBreakdown);

          // Check if dailyTimeLogs has data before rendering
          if (Object.keys(dailyTimeLogs).length > 0) {
            renderBieGraph(dailyTimeLogs);
          } else {
            console.warn('No time log data available.');
          }
        });
    })
    .catch(error => console.error("Error fetching data:", error));
}

 function updateTeamDataTime(filteredWorklogs, teamData) {
  filteredWorklogs.map(log => {
      const assigneeName = log.author.displayName || "Unassigned"; // Get the assignee for the specific log
      const timeSpentHours = log.timeSpentSeconds / 3600; // Convert seconds to hours
      teamData[assigneeName] = teamData[assigneeName] || {
        name: assigneeName,
        storyPoints: 0,
        completedStoryPoints: 0,
        timeSpent: 0,
        blockedTickets: 0,
        carryForwardTickets: 0,
        prs: 0,
        yetToStart: 0,
        completed: 0,
        epics: []
      };
  
      teamData[assigneeName].timeSpent += timeSpentHours;
    });
 }
  
  // Function to extract stateCount(No. of pullrequests) from custom field
  function getStateCountFromCustomField(customField) {
    const regex = /stateCount=(\d+)/;
    const match = customField.match(regex);
    return match ? parseInt(match[1], 10) : 0;
  }

    // Function to update epic StoryPoint allocation
    function updateEpicStoryPointAllocation(epicStoryPointAllocation, epicName, storyPoint) {
      if (!epicStoryPointAllocation[epicName]) {
        epicStoryPointAllocation[epicName] = 0;
      }
      epicStoryPointAllocation[epicName] += storyPoint;
    }

    // Function to update epic assignee involvement
    function updateEpicAssigneeInvolved(epicAssigneeInvolved, epicName, assignee) {
      if (!epicAssigneeInvolved[epicName]) {
        epicAssigneeInvolved[epicName] = new Set(); // Using Set to ensure unique assignees
      }
      epicAssigneeInvolved[epicName].add(assignee);
    }

    // Function to update epic assignee allocation
    function updateAssigneePercentageAllocation(assigneePercentageAllocation, assignee, epicName, storyPoint) {
      if (!assigneePercentageAllocation[assignee]) {
        assigneePercentageAllocation[assignee] = {};
      }

      if (!assigneePercentageAllocation[assignee][epicName]) {
        assigneePercentageAllocation[assignee][epicName] = storyPoint;
      } else {
        assigneePercentageAllocation[assignee][epicName] += storyPoint;
      }
    }

    // Function to dynamically generate team member cards
    function generateTeamMemberCards(data) {
      const container = document.getElementById('team-members-container');
      container.innerHTML = ''; // Clear any existing data

      data.forEach(member => {
        const card = document.createElement('div');
        card.className = 'team-card';
        card.innerHTML = `
        <h3>${member.name}</h3>
        <div class="main-kpi">Story Points: ${member.completedStoryPoints}/${member.storyPoints}</div>
        <p>Time Logged: ${member.timeSpent.toFixed(2)} hours</p>
        <p>Blocked Tickets: ${member.blockedTickets}</p>
        <p>Tickets Carried Over from Last Sprint: ${member.carryForwardTickets}</p>
        <p>PRs: ${member.prs}</p>
        <p>Yet to Start: ${member.yetToStart}</p>
        <p>Completed: ${member.completed}</p>
        <p>Epics: ${member.epics.length > 0 ? member.epics.join(", ") : "No Epics Assigned"}</p>
      `;
        container.appendChild(card);
      });
    }

    function generateRandomColors(numColors) {
      const colors = [];
      for (let i = 0; i < numColors; i++) {
        const randomColor = `#${Math.floor(Math.random() * 16777215).toString(16)}`;
        colors.push(randomColor);
      }
      return colors;
    }

    function renderEpicCharts(epicStoryPointAllocation, epicAssigneeInvolved, assigneePercentageAllocation) {
      // Convert epicAllocation object to labels and data arrays
      const labels = Object.keys(epicStoryPointAllocation);
      const data = Object.values(epicStoryPointAllocation);

      // if (!epicStoryPointAllocation["Unassigned EPIC"]) {
      //   epicStoryPointAllocation["Unassigned EPIC"] = 0;
      // }

      // Calculate total story points
      const totalStoryPoints = data.reduce((sum, value) => sum + value, 0);

      // Update chart with the processed data
      const epicAllocationCtx = document.getElementById('epic-allocation-chart').getContext('2d');
      const backgroundColors = generateRandomColors(labels.length);
      new Chart(epicAllocationCtx, {
        type: 'pie',
        data: {
          labels: labels, // Use the labels array here
          datasets: [{
            data: data, // Use the data array here
            backgroundColor: backgroundColors,
          }]
        },
        options: {
          layout: {
            padding: 0 // Removes padding around the chart
          },
          maintainAspectRatio: true, // Maintains the default aspect ratio
          aspectRatio: 1, // Ensures a square canvas for the pie chart
          responsive: true, // Ensures the chart resizes with its container
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  const value = context.raw; // Raw data value for the slice
                  const percentage = ((value / totalStoryPoints) * 100).toFixed(2); // Calculate percentage
                  return `${context.label}: ${value} points (${percentage}%)`;
                }
              }
            }
          }
        }
      });

      const assigneeLabels = Object.keys(epicAssigneeInvolved);
      const assigneeData = assigneeLabels.map(epic => epicAssigneeInvolved[epic].size);

        // if (!epicAssigneeInvolved["Unassigned EPIC"]) {
        //   epicAssigneeInvolved["Unassigned EPIC"] = new Set();
        // }

      // Create a mapping for tooltip display
      const tooltipData = assigneeLabels.map(epic => {
        const assignees = Array.from(epicAssigneeInvolved[epic]); // Convert Set to Array
        return assignees.join(', '); // Join assignee names with commas
      });

      const epicAssigneeCtx = document.getElementById('epic-assignee-allocation-chart').getContext('2d');
      new Chart(epicAssigneeCtx, {
        type: 'pie',
        data: {
          labels: assigneeLabels, // Use the labels array here
          datasets: [{
            data: assigneeData, // Use the data array here
            backgroundColor: backgroundColors,
          }]
        },
        options: {
          layout: {
            padding: 0 // Removes padding around the chart
          },
          maintainAspectRatio: true, // Maintains the default aspect ratio
          aspectRatio: 1, // Ensures a square canvas for the pie chart
          responsive: true, // Ensures the chart resizes with its container
          plugins: {
            tooltip: {
              callbacks: {
                label: function (tooltipItem) {
                  // Fetch assignee names for the hovered slice
                  const epic = assigneeLabels[tooltipItem.dataIndex];
                  const assignees = tooltipData[tooltipItem.dataIndex];
                  return `${epic}: ${assignees}`;
                }
              }
            }
          }
        }
      });

      renderEpicAllocationPercentageChart(assigneePercentageAllocation);
    }

    function renderEpicAllocationPercentageChart(assigneeData) {
      //   // Assuming you have predefined colors for each epic
      // const epicColors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A5']; // Example colors

      // Generate labels (assignee names) and data for the chart
      const assigneeNames = Object.keys(assigneeData);
      const epicNames = [...new Set(Object.values(assigneeData).flatMap(epicObj => Object.keys(epicObj)))]; // Unique epic names
      const dataset = [];

      // console.log(epicNames)
      // console.log(assigneeNames)

      assigneeNames.forEach(assignee => {
        // Calculate the total story points for the current assignee
        const totalStoryPoints = Object.values(assigneeData[assignee]).reduce((sum, points) => sum + points, 0);

        // Create the dataset for the current assignee
        const assigneeAllocation = epicNames.map(epic => {
          const epicPoints = assigneeData[assignee][epic] || 0;
          return (epicPoints / totalStoryPoints) * 100; // Percentage allocation for each epic
        });

        console.log(assigneeAllocation);

        // Add the data for the current assignee
        dataset.push({
          label: assignee,
          data: assigneeAllocation,
         
        });
      });

      // Chart configuration for a horizontal stacked bar chart
      const config = {
        type: 'bar',
        data: {
          labels: epicNames, // Epics will be on the x-axis
          datasets: dataset // Each dataset corresponds to one assignee with their epic allocations
        },
        options: {
          responsive: true,
          indexAxis: 'y', // Makes the chart horizontal (switches axes)
          maintainAspectRatio: true, // Maintains the default aspect ratio
          aspectRatio: 1, // Ensures a square canvas for the pie chart
          responsive: true, 
          plugins: {
            legend: {
              position: 'top',
            },
            tooltip: {
              callbacks: {
                label: function (tooltipItem) {
                  const assignee = tooltipItem.dataset.label;
                  const epic = epicNames[tooltipItem.dataIndex];
                  const percentage = tooltipItem.raw.toFixed(2);
                  return `${assignee}: ${epic} - ${percentage}%`;
                }
              }
            }
          },
          scales: {
            x: {
              stacked: true, // Stack the bars horizontally
              ticks: {
                beginAtZero: true,
                max: 100 // Max value for percentage
              }
            },
            y: {
              stacked: false, // Stack the bars vertically (for each assignee)
            }
          }
        }
      };

      const ctx = document.getElementById('epic-allocation-percentage-chart').getContext('2d');
      new Chart(ctx, config);
    }

    function renderStatusChart(statusBreakdown) {
      const labels = Object.keys(statusBreakdown); // Status names (e.g., Open, Closed)
      const data = Object.values(statusBreakdown); // Corresponding counts for each status

      const totalTickets = data.reduce((sum, count) => sum + count, 0); // Total count of tickets
    
      // Get the chart canvas context
      const statusChartCtx = document.getElementById("issue-breakdown-chart").getContext("2d");
    
      // Render the pie chart
      new Chart(statusChartCtx, {
        type: "pie",
        data: {
          labels: labels, // Status names
          datasets: [
            {
              data: data, // Counts of each status
              backgroundColor: [
                "#8e44ad",
                "#2ecc71",
                "#e74c3c",
                "#3498db",
                "#f39c12",
                "#2c3e50",
                "#117864",
              ],
            },
          ],
        },
        options: {
          layout: {
            padding: 0, // Removes padding around the chart
          },
          maintainAspectRatio: true, // Maintains the default aspect ratio
          aspectRatio: 1, // Ensures a square canvas for the pie chart
          responsive: true, // Ensures the chart resizes with its container
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  const value = context.raw; // Count of tickets in this status
                  return `${context.label}: ${value} tickets`;
                },
              },
            },
            legend: {
              position: "top",
            },
            title: {
              display: true,
              text: `Issue Status Breakdown (Total: ${totalTickets} tickets)`,
            },
          },
        },
      });
    }

    
    function renderBieGraph(dailyTimeLogs) {
      // Extract all unique assignees from dailyTimeLogs
      const uniqueAssignees = new Set();
      for (const date in dailyTimeLogs) {
        Object.keys(dailyTimeLogs[date]).forEach(assignee => uniqueAssignees.add(assignee));
      }
      const assignees = Array.from(uniqueAssignees);

      // Prepare datasets for Chart.js
      const sortedDates = Object.keys(dailyTimeLogs).sort((a, b) => new Date(a) - new Date(b)); // Sort dates
      const datasets = assignees.map((assignee, index) => {
        const color = `hsl(${index * 40}, 70%, 60%)`; // Generate a unique color for each assignee
        return {
          label: assignee,
          data: sortedDates.map(date => dailyTimeLogs[date][assignee] || 0), // Use 0 if no time log for this assignee on a given day
          backgroundColor: color
        };
      });

      // Render the chart
      const ctx = document.getElementById('timeLogBarChart').getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedDates,
          datasets: datasets
        },
        options: {
          responsive: true,
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  const assignee = context.dataset.label;
                  const hours = context.raw;
                  return `${assignee}: ${hours.toFixed(2)} hours`;
                }
              }
            }
          },
          scales: {
            x: {
              stacked: true
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: {
                display: true,
                text: 'Time Spent (hours)'
              }
            }
          }
        }
      });
    }

    // Initialize the dashboard
    document.addEventListener('DOMContentLoaded', () => {
      fetchDataAndInitialize();
    });
  </script>

</body>

</html>
